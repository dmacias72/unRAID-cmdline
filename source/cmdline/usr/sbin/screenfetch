#!/usr/bin/env bash

# screenFetch - a CLI Bash script to show system/theme info in screenshots

# Copyright (c) 2010-2015 Brett Bohnenkamper <kittykatt@kittykatt.us>

#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Yes, I do realize some of this is horribly ugly coding. Any ideas/suggestions would be
# appreciated by emailing me or by stopping by http://github.com/KittyKatt/screenFetch. You
# could also drop in on the IRC channel at irc://irc.rizon.net/screenFetch.
# to put forth suggestions/ideas. Thank you.

# Requires: bash 4.0+
# Optional dependencies: 	xorg-xdpyinfo (resoluton detection)
#						scrot (screenshot taking)
#						curl (screenshot uploading)
# Stripped down for Slackware and unRAID by Derek Macias


LANG=C
LANGUAGE=C
LC_ALL=C

scriptVersion="3.6.8a"

######################
# Settings for fetcher
######################

# This setting controls what ASCII logo is displayed.
# distro="Linux"

# This sets the information to be displayed. Available: distro, Kernel, Icons, Font, Background, ASCII. To get just the information, and not a text-art logo, you would take "ASCII" out of the below variable.
#display="distro host kernel uptime pkgs shell res disk cpu gpu mem"
valid_display=( distro host kernel uptime pkgs shell res disk cpu gpu mem )
display=( distro host kernel uptime pkgs shell res cpu gpu mem )
# Display Type: ASCII or Text
display_type="ASCII"
# Plain logo
display_logo="no"

# Colors to use for the information found. These are set below according to distribution. If you would like to set your OWN color scheme for these, uncomment the lines below and edit them to your heart's content.
# textcolor="\e[0m"
# labelcolor="\e[1;34m"

# Screenshot Settings
# This setting lets the script know if you want to take a screenshot or not. 1=Yes 0=No
screenshot=
# This setting lets the script know if you want to upload the screenshot to a filehost. 1=Yes 0=No
upload=
# This setting lets the script know where you would like to upload the file to. Valid hosts are: teknik, mediacrush, pomf, imgur, hmp, and a configurable local.
uploadLoc=
# You can specify a custom screenshot command here. Just uncomment and edit. Otherwise, we'll be using the default command: scrot -cd3.
# screenCommand="scrot -cd5"
shotfile=$(printf "screenFetch-`date +'%Y-%m-%d_%H-%M-%S'`.png")

# Verbose Setting - Set to 1 for verbose output.
verbosity=

#############################################
#### CODE No need to edit past here CODE ####
#############################################

#########################################
# Static Variables and Common Functions #
#########################################
c0="\033[0m" # Reset Text
bold="\033[1m" # Bold Text
underline="\033[4m" # Underline Text
display_index=0

# Static Color Definitions
colorize () {
    printf "\033[38;5;$1m"
}
getColor() {
    if [[ -n "$1" ]]; then
        if [[ ${BASH_VERSINFO[0]} -ge 4 ]]; then
            if [[ ${BASH_VERSINFO[0]} -eq 4 && ${BASH_VERSINFO[1]} -gt 1 ]] || [[ ${BASH_VERSINFO[0]} -gt 4 ]]; then
                tmp_color=${1,,}
            else
                tmp_color="$(tr '[:upper:]' '[:lower:]' <<< ${1})"
            fi
        else
            tmp_color="$(tr '[:upper:]' '[:lower:]' <<< ${1})"
        fi
        case "${tmp_color}" in
            'black')		color_ret='\033[0m\033[30m';;
            'red')			color_ret='\033[0m\033[31m';;
            'green')		color_ret='\033[0m\033[32m';;
            'brown')		color_ret='\033[0m\033[33m';;
            'blue')			color_ret='\033[0m\033[34m';;
            'purple')		color_ret='\033[0m\033[35m';;
            'cyan')			color_ret='\033[0m\033[36m';;
            'light grey')	color_ret='\033[0m\033[37m';;
            'dark grey')	color_ret='\033[0m\033[1;30m';;
            'light red')	color_ret='\033[0m\033[1;31m';;
            'light green')	color_ret='\033[0m\033[1;32m';;
            'yellow')		color_ret='\033[0m\033[1;33m';;
            'light blue')	color_ret='\033[0m\033[1;34m';;
            'light purple')	color_ret='\033[0m\033[1;35m';;
            'light cyan')	color_ret='\033[0m\033[1;36m';;
            'white')		color_ret='\033[0m\033[1;37m';;
            # Some 256 colors
            'orange') color_ret="$(colorize '202')";;
            # HaikuOS
            'black_haiku') color_ret="$(colorize '7')";;
        esac
        [[ -n "${color_ret}" ]] && echo "${color_ret}"
    else
        :
    fi
}

verboseOut() {
    if [[ "$verbosity" -eq "1" ]]; then
        printf "\033[1;31m:: \033[0m$1\n"
    fi
}

errorOut() {
    printf "\033[1;37m[[ \033[1;31m! \033[1;37m]] \033[0m$1\n"
}
stderrOut() {
    while IFS='' read -r line; do printf "\033[1;37m[[ \033[1;31m! \033[1;37m]] \033[0m${line}\n"; done
}


####################
#  Color Defines
####################

colorNumberToCode() {
    number="$1"
    if [[ "${number}" == "na" ]]; then
        unset code
    elif [[ $(tput colors) -eq "256" ]]; then
        code=$(colorize "${number}")
    else
        case "$number" in
            0|00) code=$(getColor 'black');;
            1|01) code=$(getColor 'red');;
            2|02) code=$(getColor 'green');;
            3|03) code=$(getColor 'brown');;
            4|04) code=$(getColor 'blue');;
            5|05) code=$(getColor 'purple');;
            6|06) code=$(getColor 'cyan');;
            7|07) code=$(getColor 'light grey');;
            8|08) code=$(getColor 'dark grey');;
            9|09) code=$(getColor 'light red');;
              10) code=$(getColor 'light green');;
              11) code=$(getColor 'yellow');;
              12) code=$(getColor 'light blue');;
              13) code=$(getColor 'light purple');;
              14) code=$(getColor 'light cyan');;
              15) code=$(getColor 'white');;
            *) unset code;;
        esac
    fi
    echo -n "${code}"
}


detectColors() {
    my_colors=$(sed 's/^,/na,/;s/,$/,na/;s/,/ /' <<< "${OPTARG}")
    my_lcolor=$(awk -F' ' '{print $1}' <<< "${my_colors}")
    my_lcolor=$(colorNumberToCode "${my_lcolor}")

    my_hcolor=$(awk -F' ' '{print $2}' <<< "${my_colors}")
    my_hcolor=$(colorNumberToCode "${my_hcolor}")
}

supported_distros="Slackware, unRAID."

displayHelp() {
    printf "${underline}Usage${c0}:\n"
    printf "  ${0} [OPTIONAL FLAGS]\n\n"
    printf "screenFetch - a CLI Bash script to show system/theme info in screenshots.\n\n"
    printf "${underline}Supported GNU/Linux Distributions${c0}:\n"
    printf "${supported_distros}" | fold -s | sed 's/^/\t/g'
    printf "\n\n"
    printf "${underline}Options${c0}:\n"
    printf "   ${bold}-v${c0}                 Verbose output.\n"
    printf "   ${bold}-o 'OPTIONS'${c0}       Allows for setting script variables on the\n"
    printf "		      command line. Must be in the following format...\n"
    printf "		      'OPTION1=\"OPTIONARG1\";OPTION2=\"OPTIONARG2\"'\n"
    printf "   ${bold}-d '+var;-var;var'${c0} Allows for setting what information is displayed\n"
    printf "		      on the command line. You can add displays with +var,var. You\n"
    printf "		      can delete displays with -var,var. Setting without + or - will\n"
    printf "		      set display to that explicit combination. Add and delete statements\n"
    printf "		      may be used in conjunction by placing a ; between them as so:\n"
    printf "		      +var,var,var;-var,var.\n"
    printf "   ${bold}-n${c0}                 Do not display ASCII distribution logo.\n"
    printf "   ${bold}-L${c0}                 Display ASCII distribution logo only.\n"
    printf "   ${bold}-N${c0}                 Strip all color from output.\n"
    printf "   ${bold}-t${c0}                 Truncate output based on terminal width (Experimental!).\n"
    printf "   ${bold}-p${c0}                 Portrait output.\n"
    printf "   ${bold}-s(u)${c0}              Using this flag tells the script that you want it\n"
    printf "		      to take a screenshot. Use the -u flag if you would like\n"
    printf "		      to upload the screenshots to one of the pre-configured\n"
    printf "		      locations. These include: teknik, pomf, imgur, mediacrush, and hmp.\n"
    printf "   ${bold}-c string${c0}          You may change the outputted colors with -c. The format is\n"
    printf "                      as follows: [0-9][0-9],[0-9][0-9]. The first argument controls the\n"
    printf "                      ASCII logo colors and the label colors. The second argument\n"
    printf "                      controls the colors of the information found. One argument may be\n"
    printf "                      used without the other.\n"
    printf "   ${bold}-a 'PATH'${c0}          You can specify a custom ASCII art by passing the path\n"
    printf "                      to a Bash script, defining \`startline\` and \`fulloutput\`\n"
    printf "                      variables, and optionally \`labelcolor\` and \`textcolor\`.\n"
    printf "                      See the \`asciiText\` function in the source code for more\n"
    printf "                      informations on the variables format.\n"
    printf "   ${bold}-S 'COMMAND'${c0}       Here you can specify a custom screenshot command for\n"
    printf "		      the script to execute. Surrounding quotes are required.\n"
    printf "   ${bold}-D 'DISTRO'${c0}        Here you can specify your distribution for the script\n"
    printf "		      to use. Surrounding quotes are required.\n"
    printf "   ${bold}-A 'DISTRO'${c0}        Here you can specify the distribution art that you want\n"
    printf "		      displayed. This is for when you want your distro\n"
    printf "                      detected but want to display a different logo.\n"
    printf "   ${bold}-E${c0}                 Suppress output of errors.\n"
    printf "   ${bold}-V${c0}                 Display current script version.\n"
    printf "   ${bold}-h${c0}                 Display this help.\n"
}


displayVersion() {
    printf ${underline}"screenFetch"${c0}" - Version ${scriptVersion}\n"
    printf "Created by and licensed to Brett Bohnenkamper <kittykatt@kittykatt.us>\n"
    printf "Stripped down for Slackware and unrAID by Derek Macias.\n\n"
    printf "This is free software; see the source for copying conditions.  There is NO warranty; not even MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
}


#####################
# Begin Flags Phase
#####################

case $1 in
    --help) displayHelp; exit 0;;
    --version) displayVersion; exit 0;;
esac


while getopts ":hsu:evVEnLNtlS:A:D:o:Bc:d:pa:" flags; do
    case $flags in
        h) displayHelp; exit 0 ;;
        s) screenshot='1' ;;
        S) screenCommand="${OPTARG}" ;;
        u) upload='1'; uploadLoc="${OPTARG}" ;;
        v) verbosity=1 ;;
        V) displayVersion; exit 0 ;;
        E) errorSuppress='1' ;;
        D) distro="${OPTARG}" ;;
        A) asc_distro="${OPTARG}" ;;
        t) truncateSet='Yes' ;;
        n) display_type='Text' ;;
        L) display_type='ASCII'; display_logo='Yes' ;;
        o) overrideOpts="${OPTARG}" ;;
        c) detectColors "${OPTARGS}" ;;
        d) overrideDisplay="${OPTARG}" ;;
        N) no_color='1' ;;
        p) portraitSet='Yes' ;;
        a) art="${OPTARG}" ;;
        :) errorOut "Error: You're missing an argument somewhere. Exiting."; exit 1 ;;
        ?) errorOut "Error: Invalid flag somewhere. Exiting."; exit 1 ;;
        *) errorOut "Error"; exit 1 ;;
    esac
done

###################
# End Flags Phase
###################


############################
# Override Options/Display
############################

if [[ "$overrideOpts" ]]; then
    verboseOut "Found 'o' flag in syntax. Overriding some script variables..."
    OLD_IFS="$IFS"
    IFS=";"
    for overopt in "${overrideOpts}"; do
        eval "${overrideOpts}"
    done
    IFS="$OLD_IFS"
fi


#########################
# Begin Detection Phase
#########################

# Distro Detection - Begin
detectdistro () {
    if [[ -z "${distro}" ]]; then
        distro="Unknown"
        # Existing File Check
        if [[ "${distro}" == "Unknown" ]]; then
            if [ -f /etc/os-release ]; then
                distrib_id=$(</etc/os-release);
                for l in $(echo $distrib_id); do
                    if [[ ${l} =~ ^ID= ]]; then
                        distrib_id=${l//*=}
                        distrib_id=${distrib_id//\"/}
                        break 1
                    fi
                done
                if [[ -n ${distrib_id} ]]; then
                    if [[ -n ${BASH_VERSINFO} && ${BASH_VERSINFO} -ge 4 ]]; then
                        distrib_id=$(for i in ${distrib_id}; do echo -n "${i^} "; done)
                        distro=${distrib_id% }
                        unset distrib_id
                    else
                        distrib_id=$(for i in ${distrib_id}; do FIRST_LETTER=$(echo -n "${i:0:1}" | tr "[:lower:]" "[:upper:]"); echo -n "${FIRST_LETTER}${i:1} "; done)
                        distro=${distrib_id% }
                        unset distrib_id
                    fi
                fi

                # Hotfixes
                [[ "${distro}" == "Slackware" ]] && [[ -f /etc/unraid-version ]] && distro="unRAID"
            fi
        fi
    fi

    if [[ -n ${distro_more} ]]; then
        distro_more="${distro} ${distro_more}"
    fi

    if [[ "${distro}" != "Haiku" ]]; then
        if [[ ${BASH_VERSINFO[0]} -ge 4 ]]; then
            if [[ ${BASH_VERSINFO[0]} -eq 4 && ${BASH_VERSINFO[1]} -gt 1 ]] || [[ ${BASH_VERSINFO[0]} -gt 4 ]]; then
                distro=${distro,,}
            else
                distro="$(tr '[:upper:]' '[:lower:]' <<< ${distro})"
            fi
        else
            distro="$(tr '[:upper:]' '[:lower:]' <<< ${distro})"
        fi
    fi

    if [[ -n ${distro_more} ]]; then
        distro_more="${distro} ${distro_more}"
    fi

    case $distro in
        unraid) distro="unRAID" ;;
    esac
    verboseOut "Finding distro...found as '${distro} ${distro_release}'"
}
# Distro Detection - End

# Host and User detection - Begin
detecthost () {
    myUser=${USER}
    myHost=${HOSTNAME}
    verboseOut "Finding hostname and user...found as '${myUser}@${myHost}'"
}

# Find Number of Running Processes
# processnum="$(( $( ps aux | wc -l ) - 1 ))"

# Kernel Version Detection - Begin
detectkernel () {
    kernel=( $(uname -srm) )
    kernel="${kernel[${#kernel[@]}-1]} ${kernel[@]:0:${#kernel[@]}-1}"
    verboseOut "Finding kernel version...found as '${kernel}'"
}
# Kernel Version Detection - End


# Uptime Detection - Begin
detectuptime () {
    unset uptime
    if [[ -f /proc/uptime ]]; then
        uptime=$(</proc/uptime)
        uptime=${uptime//.*}
    fi

    if [[ -n ${uptime} ]]; then
        secs=$((${uptime}%60))
        mins=$((${uptime}/60%60))
        hours=$((${uptime}/3600%24))
        days=$((${uptime}/86400))
        uptime="${mins}m"
        if [ "${hours}" -ne "0" ]; then
            uptime="${hours}h ${uptime}"
        fi
        if [ "${days}" -ne "0" ]; then
            uptime="${days}d ${uptime}"
        fi
    fi
    verboseOut "Finding current uptime...found as '${uptime}'"
}
# Uptime Detection - End


# Package Count - Begin
detectpkgs () {
    pkgs="Unknown"
    case "${distro}" in
        'Slackware') pkgs=$(ls -1 /var/log/packages | wc -l) ;;
    esac
    verboseOut "Finding current package count...found as '$pkgs'"
}


# CPU Detection - Begin
detectcpu () {
    REGEXP="-r"
    cpu=$(awk 'BEGIN{FS=":"} /model name/ { print $2; exit }' /proc/cpuinfo | awk 'BEGIN{FS=" @"; OFS="\n"} { print $1; exit }')
    cpun=$(grep "physical id" /proc/cpuinfo | sort | uniq | wc -l)
    if [ -z "$cpu" ]; then
        cpu=$(awk 'BEGIN{FS=":"} /Hardware/ { print $2; exit }' /proc/cpuinfo)
    fi
    loc="/sys/devices/system/cpu/cpu0/cpufreq"
    if [ -f ${loc}/bios_limit ];then
        cpu_mhz=$(awk '{print $1/1000}' "${loc}/bios_limit")
    elif [ -f $loc/scaling_max_freq ];then
        cpu_mhz=$(awk '{print $1/1000}' "${loc}/scaling_max_freq")
    else
        cpu_mhz=$(awk -F':' '/cpu MHz/{ print int($2+.5) }' /proc/cpuinfo | head -n 1)
    fi
    if [ -n "$cpu_mhz" ];then
        if [ $(echo $cpu_mhz | cut -d. -f1) -gt 999 ];then
            cpu_ghz=$(awk '{print $1/1000}' <<< "${cpu_mhz}")
            cpu="$cpu @ ${cpu_ghz}GHz"
        else
            cpu="$cpu @ ${cpu_mhz}MHz"
        fi
    fi

    if [[ "${cpun}" -gt "1" ]]; then
            cpu=$(sed $REGEXP 's/\([tT][mM]\)|\([Rr]\)|[pP]rocessor//g' <<< "${cpun}x ${cpu}" | xargs)
    else
            cpu=$(sed $REGEXP 's/\([tT][mM]\)|\([Rr]\)|[pP]rocessor//g' <<< "${cpu}" | xargs)
    fi
    verboseOut "Finding current CPU...found as '$cpu'"
}
# CPU Detection - End


# GPU Detection - Begin (EXPERIMENTAL!)
detectgpu () {
    if [ -n "$gpu" ];then
        if [ $(grep -i nvidia <<< "${gpu_info}" | wc -l) -gt 0 ];then
            gpu_info="NVidia "
        elif [ $(grep -i intel <<< "${gpu_info}" | wc -l) -gt 0 ];then
            gpu_info="Intel "
        elif [ $(grep -i amd <<< "${gpu_info}" | wc -l) -gt 0 ];then
            gpu_info="AMD "
        elif [[ $(grep -i ati <<< "${gpu_info}" | wc -l) -gt 0  || $(grep -i radeon <<< "${gpu_info}" | wc -l) -gt 0 ]]; then
            gpu_info="ATI "
        else
            gpu_info=$(cut -d ':' -f2 <<< "${gpu_info}")
            gpu_info="${gpu_info:1} "
        fi
        gpu="${gpu}"
    else
        gpu="Not Found"
    fi

    verboseOut "Finding current GPU...found as '$gpu'"
}
# GPU Detection - End


# Disk Usage Detection - Begin
detectdisk () {
    diskusage="Unknown"
    if type -p df >/dev/null 2>&1; then
        totaldisk=$(df -h --total 2>/dev/null | tail -1)
        disktotal=$(awk '{print $2}' <<< "${totaldisk}")
        diskused=$(awk '{print $3}' <<< "${totaldisk}")
        diskusedper=$(awk '{print $5}' <<< "${totaldisk}")
        diskusage="${diskused} / ${disktotal} (${diskusedper})"
        diskusage_verbose=$(sed 's/%/%%/' <<< $diskusage)
    fi
    verboseOut "Finding current disk usage...found as '$diskusage_verbose'"
}
# Disk Usage Detection - End


# Memory Detection - Begin
detectmem () {
    hw_mem=0
    free_mem=0
    human=1024
    mem_info=$(</proc/meminfo)
    mem_info=$(echo $(echo $(mem_info=${mem_info// /}; echo ${mem_info//kB/})))
    for m in $mem_info; do
        if [[ ${m//:*} = MemTotal ]]; then
            memtotal=${m//*:}
        fi

        if [[ ${m//:*} = MemFree ]]; then
            memfree=${m//*:}
        fi

        if [[ ${m//:*} = Buffers ]]; then
            membuffer=${m//*:}
        fi

        if [[ ${m//:*} = Cached ]]; then
            memcached=${m//*:}
        fi
    done

    usedmem="$(((($memtotal - $memfree) - $membuffer - $memcached) / $human))"
    totalmem="$(($memtotal / $human))"
    mem="${usedmem}MiB / ${totalmem}MiB"
    verboseOut "Finding current RAM usage...found as '$mem'"
}
# Memory Detection - End


# Shell Detection - Begin
detectshell_ver () {
    local version_data='' version='' get_version='--version'

    case $1 in
        # ksh sends version to stderr. Weeeeeeird.
        ksh)
            version_data="$( $1 $get_version 2>&1 )"
            ;;
        *)
            version_data="$( $1 $get_version 2>/dev/null )"
            ;;
    esac

    if [[ -n $version_data ]];then
        version=$(awk '
        BEGIN {
            IGNORECASE=1
        }
        /'$2'/ {
            gsub(/(,|v|V)/, "",$'$3')
            if ($2 ~ /[Bb][Aa][Ss][Hh]/) {
                gsub(/\(.*|-release|-version\)/,"",$4)
            }
            print $'$3'
            exit # quit after first match prints
        }' <<< "$version_data")
    fi
    echo "$version"
}
detectshell () {
    if [[ ! "${shell_type}" ]]; then
            shell_type=$(ps -p $(ps -p $PPID | awk '$1 !~ /PID/ {print $1}') | awk 'FNR>1 {print $1}')
            shell_type=${shell_type/-}
            shell_type=${shell_type//*\/}
    fi

    case $shell_type in
        bash)
            shell_version_data=$( detectshell_ver "$shell_type" "^GNU.bash,.version" "4" )
            ;;
        csh)
            shell_version_data=$( detectshell_ver "$shell_type" "$shell_type" "3" )
            ;;
        dash)
            shell_version_data=$( detectshell_ver "$shell_type" "$shell_type" "3" )
            ;;
        ksh)
            shell_version_data=$( detectshell_ver "$shell_type" "version" "5" )
            ;;
        tcsh)
            shell_version_data=$( detectshell_ver "$shell_type" "^tcsh" "2" )
            ;;
        zsh)
            shell_version_data=$( detectshell_ver "$shell_type" "^zsh" "2" )
            ;;
    esac

    if [[ -n $shell_version_data ]];then
        shell_type="$shell_type $shell_version_data"
    fi

    myShell=${shell_type}
    verboseOut "Finding current shell...found as '$myShell'"
}
# Shell Detection - End


# Resolution Detection - Begin
detectres () {
    if [[ -n ${DISPLAY} ]]; then
        if type -p xdpyinfo >/dev/null 2>&1; then
            xResolution=$(xdpyinfo | sed -n 's/.*dim.* \([0-9]*x[0-9]*\) .*/\1/pg' | sed ':a;N;$!ba;s/\n/ /g')
        fi
    fi
    verboseOut "Finding current resolution(s)...found as '$xResolution'"
}
# Resolution Detection - End

#######################
# End Detection Phase
#######################

takeShot () {
    if [[ -z $screenCommand ]]; then
        if [[ "${upload}" == "1" ]]; then
            shotfiles[1]=${shotfile}
            scrot -cd3 "${shotfile}"
            if [ -f "${shotfile}" ]; then
                verboseOut "Screenshot saved at '${shotfiles[@]}'"
                printf "${bold}==>${c0}  Uploading your screenshot now..."
                case "${uploadLoc}" in
                    'teknik')
                        baseurl='https://u.teknik.io'
                        uploadurl='https://api.teknik.io/upload/post'
                        ret=$(curl -sf -F file="@${shotfiles[@]}" ${uploadurl})
                        desturl="${ret##*url\":\"}"
                        desturl="${desturl%%\"*}"
                        desturl="${desturl//\\}"
                    ;;
                    'mediacrush')
                        baseurl='https://mediacru.sh'
                        uploadurl='https://mediacru.sh/api/upload/file'
                        ret=$(curl -sf -F file="@${shotfiles[@]};type=image/png" ${uploadurl})
                        filehash=$(echo "${ret}" | grep "hash" | cut -d '"' -f4)
                        desturl="${baseurl}/${filehash}"
                    ;;
                    'imgur')
                        baseurl='http://imgur.com'
                        uploadurl='http://imgur.com/upload'
                        ret=$(curl -sf -F file="@${shotfiles[@]}" ${uploadurl})
                        filehash="${ret##*hash\":\"}"
                        filehash="${filehash%%\"*}"
                        desturl="${baseurl}/${filehash}"
                    ;;
                    'pomf')
                        baseurl='http://a.pomf.se'
                        uploadurl='http://pomf.se/upload.php'
                        ret=$(curl --silent -sf -F files[]="@${shotfiles[@]}" ${uploadurl})
                        filehash="${ret##*url\":\"}"
                        filehash="${filehash%%\"*}"
                        desturl="${baseurl}/${filehash}"
                    ;;
                    'hmp')
                        baseurl='http://i.hmp.me/m'
                        uploadurl='http://hmp.me/ap/?uf=1'
                        ret=$(curl -sf -F a="@${shotfiles[@]};type=image/png" ${uploadurl})
                        desturl="${ret##*img_path\":\"}"
                        desturl="${desturl%%\"*}"
                        desturl="${desturl//\\}"
                    ;;
                    'local-example')
                        baseurl="http://www.example.com"
                        serveraddr="www.example.com"
                        scptimeout="20"
                        serverdir="/path/to/directory"
                        scp -qo ConnectTimeout="${scptimeout}" "${shotfiles[@]}" "${serveraddr}:${serverdir}"
                        desturl="${baseurl}/${shotfile}"
                    ;;
                esac
                printf "your screenshot can be viewed at ${desturl}\n"
            else
                errorOut "ERROR: Problem saving screenshot to ${shotfiles[@]}"
            fi
        else
            shotfiles[1]=${shotfile}
            if [ "$distro" == "Mac OS X" ]; then
                displays="$(system_profiler SPDisplaysDataType | grep 'Resolution:' | wc -l | tr -d ' ')"
                for (( i=2; i<=$displays; i++))
                do
                    shotfiles[$i]="$(echo ${shotfile} | sed "s/\(.*\)\./\1_${i}./")"
                done
                printf "Taking shot in 3.. "; sleep 1; printf "2.. "; sleep 1; printf "1.. "; sleep 1; printf "0.\n"; screencapture -x ${shotfiles[@]} &> /dev/null
            else scrot -cd3 "${shotfile}"; fi
            if [ -f "${shotfile}" ]; then
                verboseOut "Screenshot saved at '${shotfiles[@]}'"
            else
                errorOut "ERROR: Problem saving screenshot to ${shotfiles[@]}"
            fi
        fi
    else
        $screenCommand
    fi
}



asciiText () {
# Distro logos and ASCII outputs
    if [[ "$asc_distro" ]]; then myascii="${asc_distro}"
    elif [[ "$art" ]]; then myascii="custom"
    elif [[ "$fake_distro" ]]; then myascii="${fake_distro}"
    else myascii="${distro}"; fi
    case ${myascii} in
        "custom") source "$art" ;;
        "Slackware")
            if [[ "$no_color" != "1" ]]; then
                c1=$(getColor 'light blue') # Light Blue
                c2=$(getColor 'white') # Bold White
            fi
            if [ -n "${my_lcolor}" ]; then c1="${my_lcolor}"; c2="${my_lcolor}"; fi
            startline="1"
            fulloutput=("$c1                   :::::::"
"$c1             :::::::::::::::::::               %s"
"$c1          :::::::::::::::::::::::::           %s"
"$c1        ::::::::"${c2}"cllcccccllllllll"${c1}"::::::        %s"
"$c1     :::::::::"${c2}"lc               dc"${c1}":::::::      %s"
"$c1    ::::::::"${c2}"cl   clllccllll    oc"${c1}":::::::::    %s"
"$c1   :::::::::"${c2}"o   lc"${c1}"::::::::"${c2}"co   oc"${c1}"::::::::::   %s"
"$c1  ::::::::::"${c2}"o    cccclc"${c1}":::::"${c2}"clcc"${c1}"::::::::::::  %s"
"$c1  :::::::::::"${c2}"lc        cclccclc"${c1}":::::::::::::  %s"
"$c1 ::::::::::::::"${c2}"lcclcc          lc"${c1}":::::::::::: %s"
"$c1 ::::::::::"${c2}"cclcc"${c1}":::::"${c2}"lccclc     oc"${c1}"::::::::::: %s"
"$c1 ::::::::::"${c2}"o    l"${c1}"::::::::::"${c2}"l    lc"${c1}"::::::::::: %s"
"$c1  :::::"${c2}"cll"${c1}":"${c2}"o     clcllcccll     o"${c1}":::::::::::  %s"
"$c1  :::::"${c2}"occ"${c1}":"${c2}"o                  clc"${c1}":::::::::::  %s"
"$c1   ::::"${c2}"ocl"${c1}":"${c2}"ccslclccclclccclclc"${c1}":::::::::::::   %s"
"$c1    :::"${c2}"oclcccccccccccccllllllllllllll"${c1}":::::    %s"
"$c1     ::"${c2}"lcc1lcccccccccccccccccccccccco"${c1}"::::     %s"
"$c1       ::::::::::::::::::::::::::::::::       %s"
"$c1         ::::::::::::::::::::::::::::         %s"
"$c1            ::::::::::::::::::::::"
"$c1                 ::::::::::::")
        ;;

        "unRAID")
            if [[ "$no_color" != "1" ]]; then
                c1=$(getColor 'green') # Green
                c2=$(getColor 'light green') # Light Green
                c3=$(getColor 'white') # White
            fi
            if [ -n "${my_lcolor}" ]; then c1="${my_lcolor}"; c2="${my_lcolor}"; fi
            startline="1"
            fulloutput=("$c1            :++====+===:.                "
"$c1          ++$c3.,...=+=.~$c1=====~.             %s"
"$c1        =+.$c3++$c2++$c3.$c2=++==$c3=.$c1=======           %s"
"$c1       +,$c3++$c2+,++$c3.$c2+++===$c3..$c1========         %s"
"$c1     ,+$c3..$c2+++~++$c3~$c2++====$c3...$c1=========       %s"
"$c1     +$c3...$c2+++++++++:=+$c3.$c2=$c3==$c1~========~      %s"
"$c1    +$c3:$c2++$c3.$c2+++++++=~==$c3.$c2===$c3=.$c1========~~     %s"
"$c1   +$c3.,$c2+++$c3.$c2++++=++=$c3+$c2==.==$c3=.$c1=======~~~~    %s"
"$c1  ,,$c3++$c2++++$c3.$c2+=+:==$c3:$c2======$c3=,$c1======~~~~~~   %s"
"$c1  +$c3+$c2+++++++$c3.$c2++~+=~======$c3=.$c1~=====~~~~~~~  %s"
"$c1 =$c3=+$c2:+=+++++=+=~+=======$c3..$c1=====~~~~~~~~  %s"
"$c1 +$c3......:+++~..=========$c3=,$c1=====~~~~~~~~  %s"
"$c1 =$c3.+$c2+++,=++=+=+========$c3==$c1======~~~~~~~~  %s"
"$c1 ~$c3=+$c2:+++~+=++++=$c3.$c2======$c3=.$c1=====~~~~~~~~~  %s"
"$c1 =$c3++$c2+++++$c3.$c2++++==+$c3,$c2=~==$c3=,$c1======~~~~~~~~   %s"
"$c1 +$c3=+$c2+:++$c3.$c2+++++:===$c3.$c2=,=$c3=$c1~=====~~~~~~~~~   %s"
"$c1 +.$c3++$c2++$c3,$c2++++=~+====$c3.$c2~$c3:.$c1======~~~~~~~~    %s"
"$c1 +~$c3++$c2,$c3.$c2+++++$c3,$c2~=====$c3...$c1======~~~~~~~      %s"
"$c1  +$c3..$c2.+$c3:$c2++++$c3.$c2==~===$c3..$c1=======~~~~~~       %s"
"$c1  ~+.$c3++$c2+++++$c3.$c2===~$c3=.$c1========~~~~~         %s"
"$c1   ++.$c3++$c2+++$c3..$c2===$c3::$c1=========~~~~          %s"
"$c1     ++$c3.,~.....$c1===========~~~            %s"
"$c1       ++++===============:")
        ;;
    esac

    # Truncate lines based on terminal width.
    if [ "$truncateSet" == "Yes" ]; then
        for ((i=0; i<${#fulloutput[@]}; i++)); do
            my_out=$(printf "${fulloutput[i]}$c0\n" "${out_array}")
            my_out_full=$(echo "$my_out" | cat -v)
            termWidth=$(tput cols)
            SHOPT_EXTGLOB_STATE=$(shopt -p extglob)
            read SHOPT_CMD SHOPT_STATE SHOPT_OPT <<< ${SHOPT_EXTGLOB_STATE}
            if [[ ${SHOPT_STATE} == "-u" ]]; then
                shopt -s extglob
            fi

            stringReal="${my_out_full//\^\[\[@([0-9]|[0-9];[0-9][0-9])m}"

            if [[ ${SHOPT_STATE} == "-u" ]]; then
                shopt -u extglob
            fi

            if [[ "${#stringReal}" -le "${termWidth}" ]]; then
                echo -e "${my_out}"$c0
            elif [[ "${#stringReal}" -gt "${termWidth}" ]]; then
                ((NORMAL_CHAR_COUNT=0))
                for ((j=0; j<=${#my_out_full}; j++)); do
                    if [[ "${my_out_full:${j}:3}" == '^[[' ]]; then
                        if [[ "${my_out_full:${j}:5}" =~ ^\^\[\[[[:digit:]]m$ ]]; then
                            if [[ ${j} -eq 0 ]]; then
                                j=$((${j} + 5))
                            else
                                j=$((${j} + 4))
                            fi
                        elif [[ "${my_out_full:${j}:8}" =~ ^\^\[\[[[:digit:]]\;[[:digit:]][[:digit:]]m ]]; then
                            if [[ ${j} -eq 0 ]]; then
                                j=$((${j} + 8))
                            else
                                j=$((${j} + 7))
                            fi
                        fi
                    else
                        ((NORMAL_CHAR_COUNT++))
                        if [[ ${NORMAL_CHAR_COUNT} -ge ${termWidth} ]]; then
                            echo -e "${my_out:0:$((${j} - 5))}"$c0
                            break 1
                        fi
                    fi
                done
            fi

            if [[ "$i" -ge "$startline" ]]; then
                unset out_array[0]
                out_array=( "${out_array[@]}" )
            fi
        done

    elif [[ "$portraitSet" = "Yes" ]]; then
        for ((i=0; $i<${#fulloutput[*]}; i++)); do
            printf "${fulloutput[$i]}$c0\n"
        done

            printf "\n"

        for ((i=0; $i<${#fulloutput[*]}; i++)); do
            [[ -z "$out_array" ]] && continue
            printf "%s\n" "${out_array}"
                    unset out_array[0]
            out_array=( "${out_array[@]}" )
        done

    elif [[ "$display_logo" == "Yes" ]]; then
        for ((i=0; i<${#fulloutput[*]}; i++)); do
            printf "${fulloutput[i]}\n"
        done

    else
        #n=${#fulloutput[*]}
        for ((i=0; i<${#fulloutput[*]}; i++)); do
            # echo "${out_array[@]}"
            febreeze=$(awk 'BEGIN{srand();print int(rand()*(1000-1))+1 }')
            if [[ "${febreeze}" == "411" || "${febreeze}" == "188" || "${febreeze}" == "15" || "${febreeze}" == "166" || "${febreeze}" == "609" ]]; then
                f_size=${#fulloutput[*]}
                o_size=${#out_array[*]}
                f_max=$(( 32768 / f_size * f_size ))
                #o_max=$(( 32768 / o_size * o_size ))
                for ((a=f_size-1; a>0; a--)); do
                    while (( (rand=$RANDOM) >= f_max )); do :; done
                    rand=$(( rand % (a+1) ))
                    tmp=${fulloutput[a]} fulloutput[a]=${fulloutput[rand]} fulloutput[rand]=$tmp
                done
                for ((b=o_size-1; b>0; b--)); do
                    rand=$(( rand % (b+1) ))
                    tmp=${out_array[b]} out_array[b]=${out_array[rand]} out_array[rand]=$tmp
                done
            fi
            printf "${fulloutput[i]}$c0\n" "${out_array}"
            if [[ "$i" -ge "$startline" ]]; then
                unset out_array[0]
                out_array=( "${out_array[@]}" )
            fi
        done
    fi
    # Done with ASCII output
}

infoDisplay () {
    textcolor="\033[0m"
    [[ "$my_hcolor" ]] && textcolor="${my_hcolor}"
    #TODO: Centralize colors and use them across the board so we only change them one place.
    myascii="${distro}"
    [[ "${asc_distro}" ]] && myascii="${asc_distro}"
    case ${myascii} in
        "Slackware") labelcolor=$(getColor 'light blue');;
        "unRAID") labelcolor=$(getColor 'light green');;
    esac
    [[ "$my_lcolor" ]] && labelcolor="${my_lcolor}"
    if [[ "$art" ]]; then source "$art"; fi
    if [[ "$no_color" == "1" ]]; then labelcolor=""; bold=""; c0=""; textcolor=""; fi
    # Some verbosity stuff
    [[ "$screenshot" == "1" ]] && verboseOut "Screenshot will be taken after info is displayed."
    [[ "$upload" == "1" ]] && verboseOut "Screenshot will be transferred/uploaded to specified location."
    #########################
    # Info Variable Setting #
    #########################
    if [[ "$distro" == "unRAID" ]]; then
        if [ -e /var/local/emhttp/var.ini ]; then
             source /var/local/emhttp/var.ini 2>/dev/null
        else
            fsState="n/a"
            mdNumDisks="n/a"
            mdResync="0"
            mdResyncPos="0"
            cacheNumDevices="n/a"
            fsNumUnmountable="n/a"
        fi
    fi
    if [[ "${display[@]}" =~ "host" ]]; then myinfo=$(echo -e "${labelcolor}${myUser}$textcolor${bold}@${c0}${labelcolor}${myHost}"); out_array=( "${out_array[@]}" "$myinfo" ); ((display_index++)); fi
    if [[ "${display[@]}" =~ "distro" ]]; then
        if [[ "$distro" == "unRAID" ]]; then
            source /etc/unraid-version
            OSversion=$(cat /etc/slackware-version)
            mydistro=$(echo -e "$labelcolor OS:$textcolor $distro $version $OSversion")
        else
            if [ -n "$distro_more" ]; then mydistro=$(echo -e "$labelcolor OS:$textcolor $distro_more")
            else mydistro=$(echo -e "$labelcolor OS:$textcolor $distro $sysArch"); fi
        fi
        out_array=( "${out_array[@]}" "$mydistro" )
        ((display_index++))
    fi
    if [[ "${display[@]}" =~ "kernel" ]]; then mykernel=$(echo -e "$labelcolor Kernel:$textcolor $kernel"); out_array=( "${out_array[@]}" "$mykernel" ); ((display_index++)); fi
    if [[ "${display[@]}" =~ "uptime" ]]; then myuptime=$(echo -e "$labelcolor Uptime:$textcolor $uptime"); out_array=( "${out_array[@]}" "$myuptime" ); ((display_index++)); fi
    if [[ "${display[@]}" =~ "pkgs" ]]; then
    if [[ "$distro" == "unRAID" ]]; then
        resync="n/a"
        [[ ! $mdResync == "0" ]] && resync=$(($mdResyncPos*100/$mdResync))%
        mypkgs=$(echo -e "$labelcolor Array:$textcolor$fsState$labelcolor Parity Check:$textcolor$resync")
    else
        mypkgs=$(echo -e "$labelcolor Packages:$textcolor $pkgs")
    fi
    out_array=( "${out_array[@]}" "$mypkgs" )
    ((display_index++))
    fi
    if [[ "${display[@]}" =~ "shell" ]]; then
    if [[ "$distro" == "unRAID" ]]; then
        myshell=$(echo -e "$labelcolor Disks:$textcolor$mdNumDisks$labelcolor Cache:$textcolor$cacheNumDevices$labelcolor Disabled:$textcolor$fsNumUnmountable")
    else
    myshell=$(echo -e "$labelcolor Shell:$textcolor $myShell")
    fi
    out_array=( "${out_array[@]}" "$myshell" )
    ((display_index++))
    fi

    [[ "${fake_distro}" != "Cygwin" && "$fake_distro" != "Windows 10" ]] && if [[ "${display[@]}" =~ "disk" ]]; then mydisk=$(echo -e "$labelcolor Disk:$textcolor $diskusage"); out_array=( "${out_array[@]}" "$mydisk" ); ((display_index++)); fi
    if [[ "${display[@]}" =~ "cpu" ]]; then mycpu=$(echo -e "$labelcolor CPU:$textcolor $cpu"); out_array=( "${out_array[@]}" "$mycpu" ); ((display_index++)); fi
    if [[ "${display[@]}" =~ "gpu" ]] && [[ "$gpu" != "Not Found" ]]; then mygpu=$(echo -e "$labelcolor GPU:$textcolor $gpu"); out_array=( "${out_array[@]}" "$mygpu" ); ((display_index++)); fi
    if [[ "${display[@]}" =~ "mem" ]]; then mymem=$(echo -e "$labelcolor RAM:$textcolor $mem"); out_array=( "${out_array[@]}" "$mymem" ); ((display_index++)); fi

    if [[ "$display_type" == "ASCII" ]]; then
        asciiText
    else
        if [[ "${display[@]}" =~ "host" ]]; then echo -e " $myinfo"; fi
        if [[ "${display[@]}" =~ "distro" ]]; then echo -e "$mydistro"; fi
        if [[ "${display[@]}" =~ "kernel" ]]; then echo -e "$mykernel"; fi
        if [[ "${distro}" == "Android" ]]; then
            echo -e "$mydevice"
            echo -e "$myrom"
            echo -e "$mybaseband"
            echo -e "$mykernel"
            echo -e "$myuptime"
            echo -e "$mycpu"
            echo -e "$mymem"
        else
            if [[ "${display[@]}" =~ "uptime" ]]; then echo -e "$myuptime"; fi
            if [[ "${display[@]}" =~ "pkgs" ]]; then echo -e "$mypkgs"; fi
            if [[ "${display[@]}" =~ "shell" ]]; then echo -e "$myshell"; fi
            if [[ "${display[@]}" =~ "res" ]]; then echo -e "$myres"; fi
            if [[ "${display[@]}" =~ "disk" ]]; then echo -e "$mydisk"; fi
            if [[ "${display[@]}" =~ "cpu" ]]; then echo -e "$mycpu"; fi
            if [[ "${display[@]}" =~ "gpu" ]]; then echo -e "$mygpu"; fi
            if [[ "${display[@]}" =~ "mem" ]]; then echo -e "$mymem"; fi
        fi
    fi
}

##################
# Let's Do This!
##################

if [[ -f "$HOME/.screenfetchOR" ]]; then
    source $HOME/.screenfetchOR
fi


if [[ "$overrideDisplay" ]]; then
    verboseOut "Found 'd' flag in syntax. Overriding display..."
    OLDIFS=$IFS
    IFS=';'
    for i in ${overrideDisplay}; do
        modchar="${i:0:1}"
        if [[ "${modchar}" == "-" ]]; then
            i=${i/${modchar}}
            _OLDIFS=IFS
            IFS=,
            for n in $i; do
                if [[ ! "${display[@]}" =~ "$n" ]]; then
                    echo "The var $n is not currently being displayed."
                else
                    display=( "${display[@]/${n}}" )
                fi
            done
            IFS=$_OLDIFS
        elif [[ "${modchar}" == "+" ]]; then
            i=${i/${modchar}}
                _OLDIFS=IFS
                IFS=,
                for n in $i; do
                if [[ "${valid_display[@]}" =~ "$n" ]]; then
                    if [[ "${display[@]}" =~ "$n" ]]; then
                        echo "The $n var is already being displayed."
                    else
                                display+=($n)
                    fi
                else
                    echo "The var $n is not a valid display var."
                fi
                done
                IFS=$_OLDIFS
        else
            IFS=$OLDIFS
            i="${i//,/ }"
            display=( $i )
        fi
    done
    IFS=$OLDIFS
fi

for i in "${display[@]}"; do
    if [[ ! "$i" == "" ]]; then
        if [[ "${display[*]}" =~ "$i" ]]; then
            if [[ "$errorSuppress" == "1" ]]; then detect${i} 2>/dev/null
            else
                exec 3> >(stderrOut)
                detect${i} 2>&3
                exec 3>&-
            fi
        fi
    fi
done

infoDisplay
[ "$screenshot" == "1" ] && takeShot
[ "$exportTheme" == "1" ] && themeExport

exit 0